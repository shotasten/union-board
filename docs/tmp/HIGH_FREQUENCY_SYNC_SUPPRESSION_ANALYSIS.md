# 高頻度同期抑制機能の検討

## 📋 現在の実装

### 機能の内容

`scheduledSync`関数内で、高頻度同期の時間帯（土日13時前後20分間）でない場合、通常の同期をスキップする機能。

```typescript
// 高頻度同期の時間帯でない場合、通常の同期をスキップ（高頻度同期に任せる）
if (!forceHighFrequency && !isHighFrequencyTime) {
  Logger.log(`⏭️ 通常同期スキップ（高頻度同期時間外）: ${now.toISOString()}`);
  return;
}
```

### 実装履歴

- **実装日**: 2025年11月14日
- **コミット**: `8f5bfbf` - "feat: 土日13時前後20分間の高頻度同期機能を追加"

---

## 🔍 問題点の分析

### 1. トリガー設定の確認

現在の設定：
- **トリガー1**: `scheduledSync`（1時間おき）
- **トリガー2**: `scheduledSyncHighFrequency`（5分おき、土日13時前後）

### 2. 抑制機能の必要性

#### 現在の動作

1. **通常時（土日13時前後以外）**:
   - `scheduledSync`（1時間おき）が実行される
   - 関数内で時間帯をチェックし、高頻度時間帯でない場合は**スキップ**
   - 実際の同期は実行されない

2. **土日13時前後20分間（12:40-13:20）**:
   - `scheduledSyncHighFrequency`（5分おき）が実行される
   - 強制的に同期を実行

#### 問題点

1. **不要な複雑さ**:
   - 2つのトリガーが別々に設定されているので、重複実行の心配はない
   - 抑制機能がなくても、両方が実行されるだけ

2. **カレンダー → アプリ同期が減る**:
   - 高頻度時間帯に通常同期がスキップされる
   - カレンダー側の変更を検知する機会が減る

3. **`syncAll`内で既に最適化されている**:
   - `notesHash`で判定して、変更がない場合はスキップ（1420-1426行目）
   - 重複実行されても、実際のAPI呼び出しは増えない

---

## ⚖️ 削除した場合の影響

### メリット

1. **コードがシンプルになる**
   - 時間帯判定のロジックが不要
   - メンテナンスが容易

2. **カレンダー → アプリ同期が増える**
   - 高頻度時間帯にも通常同期が実行される
   - カレンダー側の変更をより頻繁に検知

3. **動作が分かりやすくなる**
   - 2つのトリガーが独立して動作
   - 時間帯による分岐がない

### デメリット

1. **無駄な処理が発生する可能性**
   - 高頻度時間帯に通常同期（1時間おき）も実行される
   - ただし、`notesHash`で判定しているので、実際のAPI呼び出しは増えない

2. **実行時間が増える可能性**
   - `pullFromCalendar`（カレンダー → アプリ同期）は常に実行される
   - 高頻度時間帯に通常同期が実行されると、`pullFromCalendar`が増える

---

## 📊 効果の定量評価

### 削除前（抑制機能あり）

| 時間帯 | 通常同期 | 高頻度同期 | 合計実行回数 |
|--------|---------|-----------|------------|
| **通常時** | 1時間おき | なし | 1時間おき |
| **土日13時前後** | スキップ | 5分おき | 5分おき |

### 削除後（抑制機能なし）

| 時間帯 | 通常同期 | 高頻度同期 | 合計実行回数 |
|--------|---------|-----------|------------|
| **通常時** | 1時間おき | なし | 1時間おき |
| **土日13時前後** | 1時間おき | 5分おき | 両方実行 |

### 影響

- **通常時**: 変化なし
- **土日13時前後**: 通常同期が追加で実行される（1時間おき）
  - 例: 12:40-13:20の40分間で、通常同期が1回追加実行される可能性
  - ただし、`notesHash`で判定しているので、実際のAPI呼び出しは増えない

---

## ✅ 結論

### 推奨: **抑制機能を削除** ⭐⭐⭐

**理由**:
1. **コードがシンプルになる**: 時間帯判定のロジックが不要
2. **動作が分かりやすくなる**: 2つのトリガーが独立して動作
3. **実際のAPI呼び出しは増えない**: `notesHash`で判定しているため
4. **カレンダー → アプリ同期が増える**: 高頻度時間帯にも通常同期が実行される

### 注意点

- `pullFromCalendar`（カレンダー → アプリ同期）は常に実行される
- 高頻度時間帯に通常同期が実行されると、`pullFromCalendar`が増える
- ただし、これはカレンダー側の変更を検知するために有用

### 実装方針

1. **抑制機能を削除**: 時間帯判定のロジックを削除
2. **2つのトリガーを独立して動作**: それぞれが独立して実行される
3. **`syncAll`内の最適化に任せる**: `notesHash`で判定して、変更がない場合はスキップ

---

## 📝 修正内容

### 削除するコード

```typescript
// 高頻度同期の時間帯でない場合、通常の同期をスキップ（高頻度同期に任せる）
if (!forceHighFrequency && !isHighFrequencyTime) {
  Logger.log(`⏭️ 通常同期スキップ（高頻度同期時間外）: ${now.toISOString()}`);
  return;
}
```

### 修正後のコード

```typescript
function scheduledSync(forceHighFrequency: boolean = false): void {
  try {
    const now = new Date();
    
    // 高頻度同期の時間帯の場合、または強制実行の場合
    if (forceHighFrequency) {
      Logger.log(`🚀 高頻度同期実行: ${now.toISOString()}`);
    } else {
      Logger.log(`📅 通常同期実行: ${now.toISOString()}`);
    }
    
    const result = syncAll(true); // 表示期間のみに制限
    Logger.log(`✅ 定期同期完了: 成功 ${result.success}件, 失敗 ${result.failed}件`);
    
    if (result.errors.length > 0) {
      Logger.log(`⚠️ エラー詳細: ${result.errors.join(', ')}`);
    }
  } catch (error) {
    Logger.log(`❌ 定期同期エラー: ${(error as Error).message}`);
    Logger.log((error as Error).stack);
  }
}
```

---

## 🎯 まとめ

**結論**: 抑制機能は不要。削除を推奨。

**理由**:
- コードがシンプルになる
- 動作が分かりやすくなる
- 実際のAPI呼び出しは増えない（`notesHash`で判定）
- カレンダー → アプリ同期が増える（メリット）

